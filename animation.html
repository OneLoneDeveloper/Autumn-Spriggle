<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Inscribed Rotating Rectangle (Corners Always Touch)</title>
  <style>
    :root { color-scheme: dark; }
    body { margin:0; min-height:100vh; display:grid; place-items:center; background:#0f0f12; color:#e8e8f0; font:14px/1.4 system-ui }
    .outer {
      position:relative;
      width:min(70vmin, 600px);
      aspect-ratio:1 / 1;             /* SQUARE outer is required for 4-side contact at all angles */
      border:2px solid #6b7089; border-radius:10px;
      background:#121318; box-shadow:0 10px 30px rgba(0,0,0,.35) inset;
      display:grid; place-items:center; overflow:hidden;
    }
    .inner {
      position:absolute;
      border:2px solid #ffad7a; border-radius:6px;
      background:linear-gradient(135deg, rgba(255,173,122,.12), rgba(255,111,111,.12));
      transform-origin:50% 50%;
      will-change:width,height,transform;
    }
    .hud { margin-top:14px; opacity:.85 }
    .row { display:flex; gap:12px; align-items:center; justify-content:center; }
    input[type=range]{ width:300px }
  </style>
</head>
<body>
  <div class="outer" id="outer">
    <div class="inner" id="inner"></div>
  </div>
  <div class="hud">
    <div class="row">
      <label>Speed (sec / revolution): <span id="spd">8.0</span></label>
      <input id="speed" type="range" min="2" max="20" step="0.5" value="8" />
      <button id="step">Step +10°</button>
      <button id="reset">Reset</button>
      <span id="deg">0.0°</span>
    </div>
  </div>

  <script>
    const outer = document.getElementById('outer');
    const inner = document.getElementById('inner');
    const speed = document.getElementById('speed');
    const spdLbl = document.getElementById('spd');
    const degLbl = document.getElementById('deg');
    const btnStep = document.getElementById('step');
    const btnReset = document.getElementById('reset');

    // For a rectangle with half-sizes u (x) and v (y) rotated by θ:
    // bbox width  = 2(u|cosθ| + v|sinθ|)
    // bbox height = 2(u|sinθ| + v|cosθ|)
    // We want bbox == (S,S) (square outer of side S). Solve for u,v.
    function solveHalfSizesSquare(S, theta) {
      // Reduce to first quadrant to drop absolutes safely:
      const a = theta % (Math.PI / 2);
      const c = Math.cos(a), s = Math.sin(a);
      const rhs = S / 2;
      const cos2 = c*c - s*s;               // cos(2a)
      const eps = 1e-8;

      if (Math.abs(cos2) > 1e-6) {
        const inv = 1 / cos2;
        const u = ( c*rhs - s*rhs ) * inv;  // = rhs*(c - s)/cos2
        const v = ( -s*rhs + c*rhs ) * inv; // = rhs*(c - s)/cos2
        return { u: Math.abs(u), v: Math.abs(v) };
      } else {
        // Exactly 45° (and every 90°±45°): infinite exact solutions with u = v
        // Constraint: (u + v)/√2 = rhs  => u = v = rhs / √2
        const u = rhs / Math.SQRT2;
        const v = u;
        return { u, v };
      }
    }

    // Constant angular velocity
    let periodMs = 8000; // default 8s per revolution
    spdLbl.textContent = (periodMs/1000).toFixed(1);
    let theta0 = 0;      // base angle offset
    let t0 = performance.now();

    speed.addEventListener('input', () => {
      const now = performance.now();
      // keep current visual angle continuous while changing speed
      const theta = getTheta(now);
      periodMs = Number(speed.value) * 1000;
      spdLbl.textContent = (periodMs/1000).toFixed(1);
      theta0 = theta;
      t0 = now;
    });

    btnStep.addEventListener('click', () => { theta0 += (10 * Math.PI/180); });
    btnReset.addEventListener('click', () => { theta0 = 0; t0 = performance.now(); });

    function getTheta(nowMs) {
      const omega = (2*Math.PI) / periodMs; // rad/ms
      return theta0 + omega * (nowMs - t0);
    }

    function animate(now) {
      const rect = outer.getBoundingClientRect();
      // enforce square side S from actual rendered size
      const S = Math.min(rect.width, rect.height);

      const theta = getTheta(now);
      const aMod = ((theta % (Math.PI/2)) + Math.PI/2) % (Math.PI/2); // [0,π/2)
      const { u, v } = solveHalfSizesSquare(S, theta);

      inner.style.width  = `${2*u}px`;
      inner.style.height = `${2*v}px`;
      inner.style.transform = `rotate(${theta}rad)`;

      const deg = ((theta * 180/Math.PI) % 360 + 360) % 360;
      degLbl.textContent = `${deg.toFixed(1)}°`;

      requestAnimationFrame(animate);
    }

    new ResizeObserver(() => {}).observe(outer);
    requestAnimationFrame(animate);
  </script>
</body>
</html>
